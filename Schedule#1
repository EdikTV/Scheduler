using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
//using System.Runtime.InteropServices; // Для работы с WinApi
namespace Scheduler //планировщик
{
    class Program
    {
        static void Main(string[] args)
        {
           
            Menu lolka = new Menu();
            lolka.Add_Option("Добавить дело");
            lolka.Add_Option("Просмотреть список дел (из этого пункта производится удаление и редактирование)");
            lolka.Add_Option("Выйти из программы");
            Spisok_Del spisok_del = new Spisok_Del();
            while (true)
            {
                lolka.Show();
                switch (lolka.curpos)
                {
                    case 0:
                        {
                            Delo new_delo = new Delo();
                            //spisok_del.AddDelo(new_delo);
                            //spisok_del.CurPos = Delo.count_of_dela - 2;
                            //new_delo.Change_Info(spisok_del.DeleteCurDelo, spisok_del.Change_Range);

                            spisok_del.AddDelo(new_delo);
                        }
                        break;
                    case 1:
                        {
                            spisok_del.Show_Spisok();
                        }
                        break;
                    case 2:
                        {
                            Environment.Exit(0);
                        }
                        break;
                }
            }

        }
        
    }


    class Wait
    {
        public void Wait_for(string where)
        {
            Console.WriteLine("Для выхода из " + where + " нажмите любую клавишу, например, Enter или Escape");
            Console.ReadKey();
        }
    }
    class Menu
    {
        private int menuIndic = 0; // показывает, какой сейчас пункт меню
        public char menu { get; private set; } // клавиша
        private int x;
        private int y;
        public int curpos { get; set;} // финальный выбор пользователя
        private List<string> Tasks = new List<string>(); // аналог вектора из с++, умный массив, с которым легко работать. Да, это сомнительно решение вообще добавлять ещё один список, однако мало ли будет добавлена функция сортировки и нужно будет отсортировать только видимую часть. В общем, мне данное решение кажется обоснованным.
        private string CurrentText;
        private List<string> Something_to_print_with_distance = new List<string>();
        public List<List<string>> Range { get; private set; } // это нужно для того, чтобы можно было при выводе
        public delegate void Should_be();
        private int ideal_width;
        private int ideal_lengh;//данное поле нужно для того, чтобы поля, печатающиеся после заголовка, были той же длины. Данное поле будет сравниваться с остальными
        private int Count_Lines=-1;
        private int CurHeightOfCursor=Console.WindowHeight/2;
        private int Height_of_Zagolovok=0;
        private int save_position=-1;//нужно для отслеживания предыдущего индекса для методов UpArrow и DownArrow
        private bool up_arrow = false;//просто уже настолько замучался со скроллингом, что додумался просто до костыля такого
        private bool down_arrow = false;
        private int previous_exit_from_for = 0;
        public Menu(ref List<string> menusha)
        {
            Tasks = menusha;
            Range = new List<List<string>>();
        }
        public Menu()
        {
            Range = new List<List<string>>();
        }//добавляем лазейку для тех, кто хочет использовать только функции вроде gotoxy, но не хочет работать с Show();
        public string currenttext
        {
            get
            {
                return CurrentText;
            }
        }
        public void Change_color_for_text(string text, ConsoleColor color)
        {
            Console.ForegroundColor = color; // устанавливаем цвет
            Console.WriteLine(text);
            Console.ResetColor(); // сбрасываем в стандартный
        }
        public void gotoxy(int x, int y)
        {
            Console.SetCursorPosition(x, y);
        } // перемещает курсор
        public void Set_center_for_text(string text)
        {
            int width = Console.WindowWidth;
            if (text.Length < width)
            {
                CurrentText = text.PadLeft((width - text.Length) / 2 + text.Length, ' ');
            }
        }// устанавливает текст по центру консоли
        public void Print_to_Center(string text, bool WriteLineOrWrite, int misus_heigh)
        {
            CurHeightOfCursor += misus_heigh;
            gotoxy(0, CurHeightOfCursor);//регулируем по высоте
            Set_center_for_text(text);
            if (WriteLineOrWrite)
                Console.WriteLine(CurrentText);
            else Console.Write(CurrentText);
        }
        public void Show()
        {
            if (Tasks.Count() < 1)
            {
                gotoxy(0, Console.WindowHeight / 2);
                Set_center_for_text("Нечего отображать");
                return;//раз отображать нечего - выходим из метода
            }
            while (true)
            {
                Console.Clear();
                Console.CursorVisible = false;
                for (int i = 0; i < Tasks.Count(); i++)
                {
                    if (i == 0) gotoxy(0, Console.WindowHeight / 2);
                    if (i == menuIndic)
                    {
                        Set_center_for_text(Tasks[i]);
                        Change_color_for_text(CurrentText, ConsoleColor.Cyan);
                    }
                    else
                    {
                        Set_center_for_text(Tasks[i]);
                        Console.WriteLine(CurrentText);
                    }
                }
                //menu = Console.ReadKey().KeyChar;
                switch (Console.ReadKey().Key)
                {
                    case ConsoleKey.Escape:
                        {
                            return;
                        }
                    // если нажали на Esc, то выход
                    case ConsoleKey.UpArrow:
                        {
                            if (menuIndic != 0)
                            {
                                menuIndic--;
                                continue;
                            }
                        }
                        break;
                    case ConsoleKey.W:
                        {
                            if (menuIndic != 0)
                            {
                                menuIndic--;
                                continue;
                            }
                        }
                        break;
                    case ConsoleKey.DownArrow:
                        {
                            if (menuIndic != Tasks.Count() - 1) menuIndic++;
                        }
                        break;
                    case ConsoleKey.S:
                        {
                            if (menuIndic != Tasks.Count() - 1) menuIndic++;
                        }
                        break;
                    case ConsoleKey.Enter:
                        {
                            curpos = menuIndic;
                            return;
                        }

                }

            }
        }
        public int Choice()
        {
            return curpos;
        }
        public void Clear_Options()
        {
            Tasks.Clear();
        }//удаление всех элементов
        public void Delete_Option()
        {
            Tasks.RemoveAt(curpos);
        }
        public void Add_Option(string something)
        {
            Tasks.Add(something);
        }
        public void Add_Zagolovok(string something)
        {
            Something_to_print_with_distance.Add(something);
        }
        public void Clear_Zagolovok()
        {
            Something_to_print_with_distance.Clear();
        }//удаление всех элементов заголовков
        public void Delete_Zagolovok(string something)
        {
            try
            {
                Something_to_print_with_distance.Remove(something);
            }
            catch
            {
                gotoxy(0, Console.WindowHeight / 2);
                Set_center_for_text("Что-то пошло не так. Не удалось удалить объект. Быть может, его и нет");
                Console.WriteLine(currenttext);
            }
        }
        public void Print_with_distanse(int distance)
        {
            for (int i = 0; i < Something_to_print_with_distance.Count(); i++)
            {
                if (i == 0)
                {
                    Console.Write("|{0, " + distance.ToString() + "}{1," + distance.ToString() + "}{2," + distance.ToString() + "}", "", Something_to_print_with_distance[i], "|");
                    continue;
                }
                Console.Write("{0, " + distance.ToString() + "}{1," + distance.ToString() + "}{2," + distance.ToString() + "}", "", Something_to_print_with_distance[i], "|");//Доллжно печатать заголовок через нормальную дистанцию
            }
            Console.WriteLine();//переход на новую строку
        }
        public void Print_with_norm_distanse(int stroka,  int after, char Otdelenie, ConsoleColor color=ConsoleColor.White)
        {
            //ideal_width = (Console.WindowWidth / Range[stroka].Count());
            ideal_width = (Console.BufferWidth) / Range[0].Count();
            string StupidRules = Serach_the_biggest(Range[0]);
            ideal_lengh = StupidRules.Length;
            string Zagolovok="";
            for (int i = 0; i < Range[stroka].Count(); i++)
            {
                string Stupid = Range[stroka][i];
                if (i == 0)
                {
                    string For_Print = Stupid;
                    Make_it_to_biggest(ref For_Print, StupidRules);
                    For_Print = Otdelenie + For_Print + Otdelenie;
                    Add_Space(0, after, ref For_Print);
                    Zagolovok += For_Print;
                    continue;
                }
                string For_Print_Other = Stupid;
                Make_it_to_biggest(ref For_Print_Other, StupidRules);
                Zagolovok += (Otdelenie + For_Print_Other + Otdelenie);
                Add_Space(0, after, ref Zagolovok);
            }
            Height_of_Zagolovok += 1;
            gotoxy(0, Height_of_Zagolovok);
            Set_center_for_text(Zagolovok);
            Change_color_for_text(currenttext, color);
            //Console.WriteLine(currenttext);
        }
        public void Print_with_norm_distance_zagolovok(int after, char Otdelenie, ConsoleColor color)
        {
            ideal_width = (Console.BufferWidth) / Range[0].Count();
            string StupidRules = Serach_the_biggest(Range[0]);
            ideal_lengh = StupidRules.Length;
            string Zagolovok = "";
            for (int i = 0; i < Range[0].Count(); i++)
            {
                string Stupid = Range[0][i];
                if (i == 0)
                {
                    string For_Print = Stupid;
                    Make_it_to_biggest(ref For_Print, StupidRules);
                    For_Print = Otdelenie + For_Print+Otdelenie;
                    Add_Space(0, after, ref For_Print);
                    Zagolovok += For_Print;
                    continue;
                }
                string For_Print_Other = Stupid;
                Make_it_to_biggest(ref For_Print_Other, StupidRules);
                Zagolovok += (Otdelenie + For_Print_Other+Otdelenie);
                Add_Space(0, after, ref Zagolovok);
            }
            Console.ForegroundColor = color;
            Set_center_for_text(Zagolovok);
            Console.WriteLine(currenttext);
            Console.ResetColor();
        }
        public string Serach_the_biggest(List<string> something)
        {
            string biggest = something[0];
            for(int i=1; i < something.Count(); i++)
            {
                if (something[i].Length > biggest.Length)
                {
                    biggest = something[i];
                }
            }
            return biggest;
        }
        public void Make_it_to_biggest(ref string something_to_chek,string biggest)
        {
            if(!Is_Longer(something_to_chek, biggest))
            {
                int different = biggest.Length - something_to_chek.Length;
                Add_Space(0,different,ref something_to_chek);
            }
        }
        public void Pechat_Punktov(int kol_vo_for_pechat, int after, char Otdelenie)
        {
            if (Range.Count() < 1)
            {
                gotoxy(0, Console.WindowHeight / 2);
                Set_center_for_text("Нечего отображать");
                Console.WriteLine(CurrentText);
                return;//раз отображать нечего - выходим из метода
            }
            Console.Clear();
            //List<string> SaveForChange = new List<string>();// когда юзер нажмёт на Enter, у него будет возможность выбирать нужный элемент для редактирования
            Print_with_norm_distance_zagolovok(5, '|', ConsoleColor.Yellow); // заголовок напечатан
            Height_of_Zagolovok++;
            bool first = true;
            int exit_from_for = 0;
            bool stop=false;
            if (kol_vo_for_pechat >= Range.Count())
            {
                exit_from_for = Range.Count();
            }
            else
            {
                exit_from_for = kol_vo_for_pechat+1;
            }
            if (exit_from_for > Console.BufferHeight) Console.BufferHeight = exit_from_for+3;//таким образом мы можем вместить весь список дел не зависимо от размера буфера
            for (int i=1; i < exit_from_for; i++)
            {
                Print_with_norm_distanse(i, after, Otdelenie);
            }
            if (Range.Count()==exit_from_for) {
                stop = true;
                save_position = 1;
                Height_of_Zagolovok = 0;
            }
            else
            {
                save_position = 1;
                Height_of_Zagolovok = 0;
                Console.WriteLine();
                CurrentText = " ";
                Change_color_for_text("Нажмите стрелку вниз [↓], чтобы листать дальше" +
                    "\n [Escape] - чтобы выйти из режима просмотра" +
                    "\n [Enter] - чтобы перейти в режим редактирования", ConsoleColor.Green);
                Console.WriteLine(currenttext);
            }
            while (true)
            {
                switch (Console.ReadKey().Key)
                {
                    case ConsoleKey.Escape:
                        {
                            menu = 'X';
                            return;
                        }
                    // если нажали на Esc, то выход
                    case ConsoleKey.DownArrow:
                        {
                            
                            if (!stop)
                                Down_Arrow(ref exit_from_for, ref kol_vo_for_pechat, after, Otdelenie);
                        }
                        break;
                    case ConsoleKey.Enter:
                        {
                            menuIndic = 1;
                            while (true)
                            {
                                Console.Clear();
                                int temp = exit_from_for;
                                int time;
                                Print_with_norm_distance_zagolovok(5, '|', ConsoleColor.Yellow); // заголовок напечатан
                                Height_of_Zagolovok++;
                                time = save_position;
                                if (exit_from_for == 1)
                                {
                                    time = 1;
                                    temp = kol_vo_for_pechat + 1;
                                }
                                if (save_position > exit_from_for)
                                {
                                    temp = previous_exit_from_for;
                                }
                                for (int i = time; i < temp; i++)
                                {
                                    if (i >= Range.Count())
                                    {
                                        temp = temp - Range.Count() + 1;
                                        i = 1;
                                    }
                                    if (i == menuIndic)
                                        Print_with_norm_distanse(i, after, Otdelenie, ConsoleColor.Cyan);
                                    else Print_with_norm_distanse(i, after, Otdelenie);
                                }
                                Height_of_Zagolovok = 0;
                                switch (Console.ReadKey().Key)
                                {
                                    case ConsoleKey.Escape:
                                        {
                                            curpos = -1;
                                            menu = 'X';
                                            return;
                                        }
                                    // если нажали на Esc, то выход
                                    case ConsoleKey.UpArrow:
                                        {
                                            if (menuIndic >1 )
                                            {
                                                menuIndic--;
                                                continue;
                                            }
                                        }
                                        break;
                                    case ConsoleKey.W:
                                        {
                                            if (menuIndic != 0)
                                            {
                                                menuIndic--;
                                                continue;
                                            }
                                        }
                                        break;
                                    case ConsoleKey.DownArrow:
                                        {
                                            if (menuIndic != temp - 1) menuIndic++;
                                        }
                                        break;
                                    case ConsoleKey.S:
                                        {
                                            if (menuIndic != temp - 1) menuIndic++;
                                        }
                                        break;
                                    case ConsoleKey.Enter:
                                        {
                                            curpos = menuIndic;
                                            menu = 'E';
                                            return;
                                        }
                                }
                            }
                            
                        }
                        
                }
            }//я конечно понимаю, что данный код уже второй раз встречается, однако тут всё же есть небольшие отличия. Тут уже в разы труднее было бы искать нормальное решение, чем просто скопипастить. Хотя. может, я попробую решить эту проблему делегатами, но это будет потом, когда буду делать рефакторинг кода.

        }
        public void Save_to_Range()
        {
           
                Range.Add(new List<string>());
            
                Count_Lines++;//мы не знаем, когда человек закончит добавлять элементы для печати с разделителями, потому самый рациональный способ это сейчас сделать заключение о том, что это конец. Иначе нужно серьёзно подумать, в какой момент инкрементировать данную переменную.
                foreach (string slovo in Something_to_print_with_distance)
                {
                    Range[Count_Lines].Add(slovo);
                }
        }//тут надо объяснить, дело в том, что мне нужно чётко понимать, где заголовок, а где сами данные. Также это нужно с тем, чтобы печатать много строк, а не одну + чтобы не копипастить код Add_Zagolovok для Add_Stroka
        public void Clear_Range()
        {
            Range.Clear();
            Count_Lines = -1;
        } 
        public void Cut_Zagolovki(int kol_vo_bukv)
        {
            for (int i = 0; i < Something_to_print_with_distance.Count(); i++)
            {
                if (Something_to_print_with_distance[i].Length > kol_vo_bukv)
                    Something_to_print_with_distance[i] = (Something_to_print_with_distance[i]).Substring(0, kol_vo_bukv);
            }
        }
        public bool Is_Longer(string something, string longer)
        {
            if (something.Length > longer.Length)
            {
                return true;
            }
            return false;
        }
        private void Down_Arrow(ref int exit_from_for, ref int kol_vo_for_pechat, int after, char Otdelenie)
        {
            Console.Clear();
            if (down_arrow)
            {
                exit_from_for += kol_vo_for_pechat;
                if (exit_from_for >= Range.Count())
                {
                    exit_from_for = 1;
                }
            }
            down_arrow = false;
            up_arrow = true;
            Height_of_Zagolovok = 0;
            Print_with_norm_distance_zagolovok(5, '|', ConsoleColor.Yellow); // заголовок напечатан
            Height_of_Zagolovok++;
            int time = exit_from_for;
            exit_from_for = exit_from_for + kol_vo_for_pechat;
            if (save_position == exit_from_for)
            {
                time = exit_from_for;
                exit_from_for += kol_vo_for_pechat;
                if (exit_from_for >= Range.Count())
                {
                    time = 1;
                    exit_from_for = kol_vo_for_pechat;
                }
            }
            save_position = time;
            previous_exit_from_for = exit_from_for;
            for (int i = time; i < exit_from_for; i++)
            {
                if (i >= Range.Count())
                {
                    exit_from_for = exit_from_for -Range.Count()+1;
                    i = 1;
                }
                Print_with_norm_distanse(i, after, Otdelenie);
            }// то есть отработали самый что ни на есть стандартный случай. Например, сейчас мы на 6 элементе, значит с него и начнём, а продолжать будем столько, сколько юзер захотел
             //exit_from_for = exit_from_for;//это нужно, чтобы не потерять позицию
            Console.WriteLine();
            CurrentText = " ";
            Change_color_for_text("Нажмите стрелку вниз [↓], чтобы листать дальше" +
                    "\n [Escape] - чтобы выйти из режима просмотра" +
                    "\n [Enter] - чтобы перейти в режим редактирования", ConsoleColor.Green);
            Console.WriteLine(currenttext);
            if (exit_from_for >= Range.Count()) exit_from_for = 1;
            Height_of_Zagolovok = 0;
        }
        public void Cut_String(ref string something, int lenght)
        {
            something=something.Substring(0, lenght);
        }
        public void Add_Space(int before, int after, ref string something)
        {
            for(int i = 0; i < before; i++)
            {
                something=something.Insert(0, " ");
            }
            for(int i = 0; i < after; i++)
            {
                something += " ";
            }
        }
        public void Add_Space_To_Zagolovki(int before, int after, List<string> something)
        {
            string StupidRules = " ";
            for(int i=0;i<something.Count();i++)
            {
                StupidRules = something[i];
                Add_Space(before, after, ref StupidRules);
                something[i] = StupidRules; // для меня величайшая загадка, почему нельзя было туда сразу передать ref something[i]. Оно выдавало ошибку...Пришлось костыль использовать. 
            }
        }
        ~Menu()
        {
            Clear_Options(); // очистка памяти
        }

        //∙ Отображение списка дел(дополнительные возможности, таки как сортировка, выделение текущих и просроченных и т.п. - остаются на усмотрение реализующего)



        //∙ Удаление пунктов из списка

        //∙ Редактирование списка


    }// класс, необходимый для того, чтобы сделать красивую менюшку для пунктов и не только
    //Надо, наверное, объяснить, зачем я делаю класс Меню достаточно универсальным. Дело в том, что этот класс можно будет без проблем, без тоскания за собой сотни других классов применить в другом проекте. Кроме, того я везде стараюсь использовать по-максимуму SOLID и GRASP. У меня каждый класс решает конкретную задачу, используется принцип "Информационный эксперт" и "Слабая связность". Это моих два любимых друга на данный момент.
    class Spisok_Del
    {
        private List<Delo> Dela = new List<Delo>();
        public int CurPos = 0;
        private Menu JustForBeauty;
        public Spisok_Del()
        {
            try
            {
                JustForBeauty = new Menu();
            }
            catch(Exception e)
            {
                Console.Clear();
                Console.WriteLine("Нам очень жаль, однако для работы с данным классом нужен класс Delo и класс Menu из пространства имён Scheduler");
                Console.WriteLine("Код ошибки: " + e);
                Task.Delay(5000).GetAwaiter().GetResult();
                Environment.Exit(0);
            }
            JustForBeauty.Add_Zagolovok("Имя задачи");
            JustForBeauty.Add_Zagolovok("Сложность");
            JustForBeauty.Add_Zagolovok("Актуальность");
            JustForBeauty.Add_Zagolovok("Время");
            JustForBeauty.Add_Zagolovok("Дата");
            JustForBeauty.Save_to_Range();//таким образом у нас изначально будут заголовки
            JustForBeauty.Cut_Zagolovki(Console.WindowWidth/5);//подбираем ширину под размер окна
            JustForBeauty.Clear_Zagolovok();//чтобы можно было добавлять новые
        }
        public void AddDelo(Delo something)
        {
            Dela.Add(something);
            JustForBeauty.Clear_Zagolovok();//а мало ли было тут что-то
            JustForBeauty.Add_Zagolovok(something.name);
            JustForBeauty.Add_Zagolovok(something.difficult.ToString());
            JustForBeauty.Add_Zagolovok(something.is_actual.ToString());
            JustForBeauty.Add_Zagolovok(something.hour.ToString()+":"+something.minutes.ToString()+":"+something.sec.ToString());
            JustForBeauty.Add_Zagolovok(something.day.ToString()+"."+something.month.ToString()+"."+something.year.ToString());
            JustForBeauty.Save_to_Range();
            JustForBeauty.Clear_Zagolovok();
        }
        public void DeleteCurDelo()
        {
            Dela.RemoveAt(CurPos);
            Change_Range();
        }//удаляет текущее дело из списка
        public void DeleteAll()
        {
            Dela.Clear();
        }// удаляет все элементы
        public void Show_Spisok()
        {
            JustForBeauty.Clear_Options();
            JustForBeauty.Add_Option("Просмотреть весь список целиком");
            JustForBeauty.Add_Option("Смотреть список частями (по нескольку элементов)");
            JustForBeauty.Show();
            JustForBeauty.Clear_Options();
            if (JustForBeauty.curpos == 0)
            {
                JustForBeauty.curpos = 0;
                JustForBeauty.Pechat_Punktov(JustForBeauty.Range.Count() - 1, 5, '|');
            }
            else
            {
                JustForBeauty.Set_center_for_text("Укажите, пожалуйста, количество, которое будет выводится за раз." +
                    "\nУчитывайте, что сейчас всего " + JustForBeauty.Range.Count() + " элементов");
                Console.WriteLine(JustForBeauty.currenttext);
                Console.WriteLine("Осуществляется ввод в с клавиатуры");
                int how_much = 1;
                try
                {
                    how_much = Int32.Parse(Console.ReadLine());
                    JustForBeauty.Pechat_Punktov(how_much - 1, 5, '|');
                }
                catch (Exception e)
                {
                    Console.WriteLine("Ой, что-то пошло не так, но не волнуйтесь: вы будете возвращены назад через 5 секунд.\nПосле чего сможете попробовать вновь");
                    Console.WriteLine("Код ошибки: " + e);
                    Task.Delay(5000).GetAwaiter().GetResult();
                    how_much = 1;
                    return;
                }
            }
            if (JustForBeauty.menu == 'E')
            {
                CurPos = JustForBeauty.curpos-1;
                Dela[CurPos].Change_Info(DeleteCurDelo, Change_Range);
            }
        }
        public void Change_Range()
        {
            JustForBeauty.Clear_Range();
            JustForBeauty.Add_Zagolovok("Имя задачи");
            JustForBeauty.Add_Zagolovok("Сложность");
            JustForBeauty.Add_Zagolovok("Актуальность");
            JustForBeauty.Add_Zagolovok("Время");
            JustForBeauty.Add_Zagolovok("Дата");
            JustForBeauty.Save_to_Range();//таким образом у нас изначально будут заголовки
            JustForBeauty.Cut_Zagolovki(Console.WindowWidth / 5);//подбираем ширину под размер окна
            JustForBeauty.Clear_Zagolovok();//чтобы можно было добавлять новые
            foreach (Delo something in Dela)
            {
                JustForBeauty.Clear_Zagolovok();//а мало ли было тут что-то
                JustForBeauty.Add_Zagolovok(something.name);
                JustForBeauty.Add_Zagolovok(something.difficult.ToString());
                JustForBeauty.Add_Zagolovok(something.is_actual.ToString());
                JustForBeauty.Add_Zagolovok(something.hour.ToString() + ":" + something.minutes.ToString() + ":" + something.sec.ToString());
                JustForBeauty.Add_Zagolovok(something.day.ToString() + "." + something.month.ToString() + "." + something.year.ToString());
                JustForBeauty.Save_to_Range();
                JustForBeauty.Clear_Zagolovok();
            }//я и сам осознаю, насколько это костыль переписывать всё по новой и какую это даёт нагрузку. Куда лучше было бы переписать один нужный элемент, однако сходу я не догадался как да и времени уже нету, я слишком долго сижу над этой программой
        }
    }
    
    class Delo
    {
        public int difficult { get; private set; }
        public int year { get; private set; }
        public int month { get; private set; }
        public int day { get; private set; }
        public int hour { get; private set; }
        public int minutes { get; private set; }
        public int sec { get; private set; }
        public bool is_actual { get; private set; }
        public string name { get; private set; }
        public delegate void Add_some_function(); // так как при проектировании, то есть ещё в самом начале было принято, судя по всему, не самое хорошее решение касательно того, что какой класс делает, то пришлось создавать делегат, в который передаётся метод удаления элемента из списка 
        private const int Count_of_Monthes = 12;
        private const int Count_of_Days = 31;
        private const int Count_hour = 24;
        private const int Count_minutes = 60;
        private const int Count_sec = 60;
        private const int Count_difficult = 5;
        static public int count_of_dela { get; private set; }
        public Delo(string name = "Новая задача")
        {
            this.name = name; // можно было бы в параметрах указать _name и сделать просто name=_name, но я не хочу таким заниматься, на мой взгляд, это уже был бы какой-то костыль
            is_actual = true; // новая задача априори не может быть сразу же просроченной
            count_of_dela++;
            difficult = 1;
        }
        ~Delo()
        {
            count_of_dela--;
        }
        public void Change_Difficult()
        {
            Console.Clear();
            List<string> Options = new List<string>();
            AddInCycle(ref Options, Count_difficult);
            Menu JustForBeuty = new Menu(ref Options);
            JustForBeuty.gotoxy(0, Console.WindowHeight / 2);
            JustForBeuty.Set_center_for_text("Введите новую сложность: ");
            Console.WriteLine(JustForBeuty.currenttext);
            JustForBeuty.Show();
            difficult = JustForBeuty.Choice() + 1;//нумерация же с нуля начинается, потому можно просто по индексу отстледить, прибавив единицу :)
        }
        public void Change_Date()
        {
            Console.Clear();
            List<string> Options = new List<string>();
            AddInCycle(ref Options, Count_of_Monthes);
            Menu JustForBeuty = new Menu(ref Options);
            JustForBeuty.gotoxy(0, Console.WindowHeight / 2);
            JustForBeuty.Set_center_for_text("Введите новую дату\nДля начала введите год с клавиатуры ");
            Console.WriteLine(JustForBeuty.currenttext);
            try
            {
                year = Convert.ToInt32(Console.ReadLine());
                if (year < 0)
                {
                    JustForBeuty.Set_center_for_text("Год не может быть отрицательным. Давайте я запишу текущий год");
                    Console.WriteLine(JustForBeuty.currenttext);
                    year = DateTime.Now.Year; // записываем текущий год вместо ерунды
                }
            }
            catch
            {
                JustForBeuty.Set_center_for_text("Что-то пошло не так, был зафиксирован неадекватный ввод\nСтрашного в этом мало: Вы сможете отредактировать данный параметр позднее\nА на данный момент будет вписан текущий год");
                Console.WriteLine(JustForBeuty.currenttext);
                year = DateTime.Now.Year; // записываем текущий год вместо мусора
            }
            JustForBeuty.Set_center_for_text("Теперь месяц");
            Console.WriteLine(JustForBeuty.currenttext);
            Task.Delay(5000).GetAwaiter().GetResult();//делаем задержку по времени, чтобы пользователь успел понять, что ему нужно вводить
            JustForBeuty.Show();
            month = JustForBeuty.Choice() + 1;
            JustForBeuty.Set_center_for_text("Теперь день");
            Console.WriteLine(JustForBeuty.currenttext);
            Task.Delay(5000).GetAwaiter().GetResult();//делаем задержку по времени, чтобы пользователь успел понять, что ему нужно вводить
            Options.Clear();
            JustForBeuty.Clear_Options();
            AddInCycle(ref Options, Count_of_Days);
            int j = 0;
            do
            {
                j++;
                if (j > 1) JustForBeuty.Set_center_for_text("Вы выбрали некорректное значение.\nУчитывайте, что в году 12 месяцев, из них 30 дней в 4 месяцах: сентябрь, апрель, июнь, ноябрь" +
                      "\n28 или 29 дней в феврале (в зависимости от того, высокостный ли год)" +
                      "\nВ остальных 7 месяцах 31 день");
                Console.WriteLine(JustForBeuty.currenttext);
                JustForBeuty.Show();
                day = JustForBeuty.Choice() + 1;
            }
            while (((month == 2) && (day > 29)) || ((month == 4) && (day > 30)) || ((month == 6) && (day > 30)) || ((month == 9) && (day > 30)) || ((month == 11) && (day > 30)) || (day > 32));
            JustForBeuty.Set_center_for_text("Дата была изменена");
            Console.WriteLine(JustForBeuty.currenttext);
            Task.Delay(5000).GetAwaiter().GetResult();//делаем задержку по времени, чтобы пользователь успел понять, что ему нужно вводить
            JustForBeuty.Clear_Options();
            Options.Clear();
        }
        public void Change_Time()
        {
            Console.Clear();
            List<string> Options = new List<string>();
            AddInCycle(ref Options, Count_hour);
            Menu JustForBeuty = new Menu(ref Options);
            JustForBeuty.gotoxy(0, Console.WindowHeight / 2);
            JustForBeuty.Set_center_for_text("Укажите часы");
            Console.WriteLine(JustForBeuty.currenttext);
            Task.Delay(5000).GetAwaiter().GetResult();//делаем задержку по времени, чтобы пользователь успел понять, что ему нужно вводить
            JustForBeuty.Show();
            hour = JustForBeuty.Choice() + 1;
            JustForBeuty.Set_center_for_text("Теперь минуты");
            Console.WriteLine(JustForBeuty.currenttext);
            Task.Delay(5000).GetAwaiter().GetResult();//делаем задержку по времени, чтобы пользователь успел понять, что ему нужно вводить
            Options.Clear();
            JustForBeuty.Clear_Options();
            AddInCycle(ref Options, Count_minutes);
            minutes = JustForBeuty.Choice() + 1;
            JustForBeuty.Set_center_for_text("Теперь секунды");
            Console.WriteLine(JustForBeuty.currenttext);
            Task.Delay(5000).GetAwaiter().GetResult();//делаем задержку по времени, чтобы пользователь успел понять, что ему нужно вводить
            Options.Clear();
            AddInCycle(ref Options, Count_sec);
            JustForBeuty.Show();
            sec = JustForBeuty.Choice() + 1;
            JustForBeuty.Clear_Options();
            Options.Clear();
        }
        public void Change_Actual()
        {
            Console.Clear();
            List<string> Options = new List<string>();
            Options.Add("Завершено");
            Options.Add("Актуально");
            Menu JustForBeuty = new Menu(ref Options);
            JustForBeuty.Show();
            is_actual = Convert.ToBoolean(JustForBeuty.Choice());
        }
        public void Change_name()
        {
            Console.Clear();
            List<string> Options = new List<string>();
            AddInCycle(ref Options, Count_of_Monthes);
            Menu JustForBeuty = new Menu(ref Options);
            JustForBeuty.gotoxy(0, Console.WindowHeight / 2);
            JustForBeuty.Set_center_for_text("Введите новое имя с клавиатуры");
            Console.WriteLine(JustForBeuty.currenttext);
            string temp = name;
            try
            {
                name = Console.ReadLine();
            }
            catch
            {
                JustForBeuty.Set_center_for_text("Что-то пошло не так. Поменять имя не удалось. Попробуйте снова");
                Console.WriteLine(JustForBeuty.currenttext);
                name = temp;//Оставили прежнее имя задачи
            }
        }
        private void AddInCycle(ref List<string> Options, int Case)
        {
            for (int i = 1; i < Case; i++)
            {
                Options.Add("" + i);
            }
        }
        private void What_is_changing(object menu)
        {
            Menu menu_for_change = (Menu)menu;//дааа, вот это костыли си шарп плодит. В С++ с многопотоком намного проще. Наверное, усложнили, чтобы такие как я меньше с этим игрались
                menu_for_change.gotoxy(0, 0);
                menu_for_change.Set_center_for_text("Редактирование дела: " + name +
                    "\n" + name + "\t" + difficult.ToString() + "\t" + day.ToString() + "." + month.ToString() + "." + year.ToString() + "\t" + hour.ToString() + ":" + minutes.ToString() + ":" + sec.ToString() + "\t" + is_actual.ToString());
               menu_for_change.Change_color_for_text(menu_for_change.currenttext, ConsoleColor.Yellow);
        }
        public void Change_Info(Add_some_function del, Add_some_function change)
        {
            List<string> textovochka = new List<string>();
            Menu menu_for_change = new Menu(ref textovochka);
            Console.Clear(); // очищаем консоль от всего, что было до этого
            menu_for_change.Set_center_for_text("Редактирование дела: " + name+
                "\n"+name+"\t"+difficult.ToString()+"\t"+day.ToString()+"."+month.ToString()+"."+year.ToString()+"\t"+hour.ToString()+":"+minutes.ToString()+":"+sec.ToString()+"\t"+is_actual.ToString());
            textovochka.Add("Поменять сложность");
            textovochka.Add("Поменять дату");
            textovochka.Add("Поменять время");
            textovochka.Add("Поменять название");
            textovochka.Add("Поменять статут актуальности");
            textovochka.Add("Удалить элемент");
            textovochka.Add("Я не хочу больше ничего редактировать");
            while (true)
            {
                Console.WriteLine(menu_for_change.currenttext);//да уж, не удобно как-то получилось, что метод Show() делает Console.Clear(), но там это реально нужно. А добавлять в метод Show() вот эту логику с отображением дела...связность сильная будет
                Thread thr1 = new Thread(new ParameterizedThreadStart(What_is_changing)); //да здравствует многопоток
                thr1.Start(menu_for_change);
                menu_for_change.Show();
                thr1.Join();//чего-то я в этой жизни не понимаю, оно должно было тут завершать поток и в след. итерации снова включать, а оно как-то костыльно работает)
                switch (menu_for_change.Choice())
                {
                    case 0:
                        {
                            Change_Difficult();
                        }
                        break;
                    case 1:
                        {
                            Change_Date();
                        }
                        break;
                    case 2:
                        {
                            Change_Time();
                        }
                        break;
                    case 3:
                        {
                            Change_name();
                        }
                        break;
                    case 4:
                        {
                            Change_Actual();
                        }
                        break;
                    case 5:
                        {
                            del();
                            return;
                        }
                    case 6:
                        {
                            change();
                            return;//я бы вызвал деструктор, однако в си шарпе нельзя таким промышлять, тут есть сборщик мусора. Ну, объект рано или поздно удалиться, так как единственное место, где он нужен, это в классе список дел. А оттуда я его могу уже удалить
                        }
                }
            }
        }
    }
}
